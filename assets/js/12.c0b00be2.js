(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{280:function(t,s,a){t.exports=a.p+"assets/img/outer_sort.drawio.3a8ab79a.svg"},310:function(t,s,a){"use strict";a.r(s);var i=a(14),e=Object(i.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"排序算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#排序算法"}},[t._v("#")]),t._v(" 排序算法")]),t._v(" "),s("h2",{attrs:{id:"内存排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存排序"}},[t._v("#")]),t._v(" 内存排序")]),t._v(" "),s("p",[t._v("内存排序是指整个排序算法都在内存中进行，一般来说排序前会将全量数据加载到内存中。")]),t._v(" "),s("p",[t._v("内排序的种类比较多，不同的排序方式的复杂度也不一样。")]),t._v(" "),s("ul",[s("li",[s("RouterLink",{attrs:{to:"/algorithm/sort/初级排序.html"}},[t._v("初级排序汇总")])],1),t._v(" "),s("li",[s("RouterLink",{attrs:{to:"/algorithm/sort/归并排序.html"}},[t._v("归并排序")])],1),t._v(" "),s("li",[s("RouterLink",{attrs:{to:"/algorithm/sort/quick/快速排序.html"}},[t._v("快速排序")])],1),t._v(" "),s("li",[s("RouterLink",{attrs:{to:"/algorithm/sort/字符串排序.html"}},[t._v("字符串排序")])],1)]),t._v(" "),s("h2",{attrs:{id:"外排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#外排序"}},[t._v("#")]),t._v(" 外排序")]),t._v(" "),s("p",[t._v("外部排序是指当需要排序的数据量大于内存最大可用量时，数据需要借助外部存储器进行排序过程。\n外排序常见的是外部归并排序，我们这里只探讨这种排序方式。")]),t._v(" "),s("p",[t._v("外部归并排序可以解析成两部分：")]),t._v(" "),s("ol",[s("li",[t._v("内存排序。按照不超过内存大小，将待排序内容分段，每段将数据加载到内存中进行排序。排好序的数据段又称为"),s("strong",[t._v("归并段")]),t._v("。\n排序完毕的归并段被写入外存中。")]),t._v(" "),s("li",[t._v("合并，将外存中的归并段进行归并。同样归并时只加载每个归并段的头（因为1中已经排好序），进行归并后再写回外存中。")])]),t._v(" "),s("p",[s("img",{attrs:{src:a(280),alt:""}})]),t._v(" "),s("p",[t._v("我们在上图中可以看到，对于长度 = 10的数据，在内存 = 4的机器中是没法直接使用内存排序的。因此使用外部排序第一步就是用内存排序，分为最大为4的若干归并段。\n之后第二步合并时，同样使用最大不超过4的内存，每次合并k个，称为k路平衡归并。这里k=2，又被称为2路平衡归并。")]),t._v(" "),s("p",[t._v("我们会发现，对于m个归并段，使用k路归并来说k值越大，归并的次数越少。设归并的次数为s，那么s = "),s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",[s("semantics",[s("mrow",[s("mo",[t._v("⌊")]),s("mi",[t._v("l")]),s("mi",[t._v("o")]),s("mi",[t._v("g")]),s("mrow",[s("msub",[s("mrow"),s("mi",[t._v("k")])],1)],1),s("mrow",[s("mi",[t._v("m")])],1),s("mo",[t._v("⌋")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("\\lfloor log{_k}{m} \\rfloor")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"strut",staticStyle:{height:"0.75em"}}),s("span",{staticClass:"strut bottom",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"base textstyle uncramped"},[s("span",{staticClass:"mopen"},[t._v("⌊")]),s("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.01968em"}},[t._v("l")]),s("span",{staticClass:"mord mathit"},[t._v("o")]),s("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.03588em"}},[t._v("g")]),s("span",{staticClass:"mord textstyle uncramped"},[s("span",{staticClass:"mord"},[s("span"),s("span",{staticClass:"vlist"},[s("span",{staticStyle:{top:"0.15em","margin-right":"0.05em"}},[s("span",{staticClass:"fontsize-ensurer reset-size5 size5"},[s("span",{staticStyle:{"font-size":"0em"}},[t._v("​")])]),s("span",{staticClass:"reset-textstyle scriptstyle cramped"},[s("span",{staticClass:"mord mathit",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")])])]),s("span",{staticClass:"baseline-fix"},[s("span",{staticClass:"fontsize-ensurer reset-size5 size5"},[s("span",{staticStyle:{"font-size":"0em"}},[t._v("​")])]),t._v("​")])])])]),s("span",{staticClass:"mord textstyle uncramped"},[s("span",{staticClass:"mord mathit"},[t._v("m")])]),s("span",{staticClass:"mclose"},[t._v("⌋")])])])]),t._v("。并且由于每次归并都会在经历一次读外存的过程，因此我们希望k尽可能大。")]),t._v(" "),s("p",[t._v("但与此同时，k值的增大意味着同一时间需要加载到内存中的归并排序数据变多。因此我们会发现当m变多时，归并排序的cpu耗时也会增加。")]),t._v(" "),s("p",[t._v("因此我们优化外部归并排序的点在于：")]),t._v(" "),s("ol",[s("li",[t._v("尽可能增加k路排序的k。")]),t._v(" "),s("li",[t._v("尽可能减少初始归并段数量m。")])]),t._v(" "),s("p",[t._v("下面介绍几种不同的优化思路。")]),t._v(" "),s("ul",[s("li",[s("RouterLink",{attrs:{to:"/algorithm/sort/loser_tree/败者树.html"}},[t._v("败者树")])],1)])])}),[],!1,null,null,null);s.default=e.exports}}]);