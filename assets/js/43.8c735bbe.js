(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{333:function(e,n,s){"use strict";s.r(n);var a=s(14),o=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"bufferallocator中的池化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bufferallocator中的池化"}},[e._v("#")]),e._v(" BufferAllocator中的池化")]),e._v(" "),n("p",[e._v("从整体来说，分配缓冲区的时候Netty利用了缓存机制，尽最大可能复用重复的内存，并减少内存碎片。")]),e._v(" "),n("p",[e._v("Netty的池化通过PoolChunk来完成，可以认为每次申请Buffer时，都是通过某个PoolChunk中的共享内存来分配的。具体策略如下：")]),e._v(" "),n("h3",{attrs:{id:"poolarena"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#poolarena"}},[e._v("#")]),e._v(" PoolArena")]),e._v(" "),n("p",[e._v("对于PoolArena来说，其内部按照6级分位来划分内存空间。每一级单独维护缓存。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("        q100 = new PoolChunkList(this, null, 100, Integer.MAX_VALUE, chunkSize);\n        q075 = new PoolChunkList(this, q100, 75, 100, chunkSize);\n        q050 = new PoolChunkList(this, q075, 50, 100, chunkSize);\n        q025 = new PoolChunkList(this, q050, 25, 75, chunkSize);\n        q000 = new PoolChunkList(this, q025, 1, 50, chunkSize);\n        qInit = new PoolChunkList(this, q000, Integer.MIN_VALUE, 25, chunkSize);\n")])])]),n("p",[e._v("6个chunkList形成一个双向链表，里面对应的内存分片会根据当前占用的空间大小进行动态调整。")]),e._v(" "),n("p",[e._v("q025中25和75的含义是，当前chunkList分配的单片最多占用75%的的chunkSize，最少占用25%的chunkSize。对于不满足的场景，会顺延到对应的ChunkList中。")]),e._v(" "),n("ul",[n("li",[e._v("每次申请内存时，从head（init）开始申请，由于init中的最大内存量是很少的，因此如果申请失败，就转而到下一个（25）中申请。如果申请成功了，对应的chunk会再次检查自己是否还满足当前百分位，如果不满足，那么自动挪到对应的list中。")]),e._v(" "),n("li",[e._v("每次释放内存时，和申请一样在释放后进行调整。")])]),e._v(" "),n("p",[n("strong",[e._v("这样做可以保证每次都先从内存空间最大的chunk中申请内存，来保证空间利用率的最大化。")])]),e._v(" "),n("h3",{attrs:{id:"poolchunk"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#poolchunk"}},[e._v("#")]),e._v(" PoolChunk")]),e._v(" "),n("p",[e._v("PoolChunk是PoolArena中的最小单元。")]),e._v(" "),n("p",[e._v("Chunk内部也有如下概念：")]),e._v(" "),n("ul",[n("li",[e._v("page表示内存分片的最小单位。")]),e._v(" "),n("li",[e._v("run表示page集合。")]),e._v(" "),n("li",[e._v("chunk表示run集合。")]),e._v(" "),n("li",[e._v("chunkSize=maxPages * pageSize")])]),e._v(" "),n("p",[e._v("每次Buffer分配的时候，从上到下寻找第一个可分配的空间。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  A chunk has the following layout:\n\n     /-----------------\\\n     | run             |\n     |                 |\n     |                 |\n     |-----------------|\n     | run             |\n     |                 |\n     |-----------------|\n     | unalloctated    |\n     | (freed)         |\n     |                 |\n     |-----------------|\n     | subpage         |\n     |-----------------|\n     | unallocated     |\n     | (freed)         |\n     | ...             |\n     | ...             |\n     | ...             |\n     |                 |\n     |                 |\n     |                 |\n     \\-----------------/\n\n")])])]),n("h4",{attrs:{id:"内存申请"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存申请"}},[e._v("#")]),e._v(" 内存申请")]),e._v(" "),n("p",[e._v("申请策略保存在PoolArena的父类SizeClasses。")]),e._v(" "),n("p",[e._v("可以理解为是一个基于分组的内存分配策略。")]),e._v(" "),n("p",[e._v("sizeClasses中的内存分配，可以理解为每个分组都是上一个分组的2^n倍。因此group大小按照log方式保存。")]),e._v(" "),n("p",[n("strong",[e._v("这样的好处在于对于任意size的申请来说，首先可以通过这个表格对照来计算出最佳的大小和类型（subPage或run）。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" * sizeClasses: Complete table of [index, log2Group, log2Delta, nDelta, isMultiPageSize,\n *                 isSubPage, log2DeltaLookup] tuples.\n *     index: Size class index.\n *     log2Group: Log of group base size (no deltas added).\n *     log2Delta: Log of delta to previous size class.\n *     nDelta: Delta multiplier.\n *     isMultiPageSize: 'yes' if a multiple of the page size, 'no' otherwise.\n *     isSubPage: 'yes' if a subpage size class, 'no' otherwise.\n *     log2DeltaLookup: Same as log2Delta if a lookup table size class, 'no'\n *                      otherwise.\n *   (index, log2Group, log2Delta, nDelta, isMultiPageSize, isSubPage, log2DeltaLookup)\n * <p>\n *   ( 0,     4,        4,         0,       no,             yes,        4)\n *   ( 1,     4,        4,         1,       no,             yes,        4)\n *   ( 2,     4,        4,         2,       no,             yes,        4)\n *   ( 3,     4,        4,         3,       no,             yes,        4)\n * <p>\n *   ( 4,     6,        4,         1,       no,             yes,        4)\n *   ( 5,     6,        4,         2,       no,             yes,        4)\n *   ( 6,     6,        4,         3,       no,             yes,        4)\n *   ( 7,     6,        4,         4,       no,             yes,        4)\n * <p>\n *   ( 8,     7,        5,         1,       no,             yes,        5)\n *   ( 9,     7,        5,         2,       no,             yes,        5)\n *   ( 10,    7,        5,         3,       no,             yes,        5)\n *   ( 11,    7,        5,         4,       no,             yes,        5)\n *   ...\n *   ...\n *   ( 72,    23,       21,        1,       yes,            no,        no)\n *   ( 73,    23,       21,        2,       yes,            no,        no)\n *   ( 74,    23,       21,        3,       yes,            no,        no)\n *   ( 75,    23,       21,        4,       yes,            no,        no)\n * <p>\n *   ( 76,    24,       22,        1,       yes,            no,        no)\n")])])]),n("h4",{attrs:{id:"数据结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[e._v("#")]),e._v(" 数据结构")]),e._v(" "),n("p",[e._v("handle：")]),e._v(" "),n("p",[e._v("是一个长数字，bit抽象成如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("oooooooo ooooooos ssssssss ssssssue bbbbbbbb bbbbbbbb bbbbbbbb bbbbbbbb\n")])])]),n("ul",[n("li",[e._v("o：15bit，表示chunk中的page偏移量。")]),e._v(" "),n("li",[e._v("s：15bit，表示当前run中的page数量。")]),e._v(" "),n("li",[e._v("u：1bit，表示是否被使用。")]),e._v(" "),n("li",[e._v("e：1bit，表示是否是subPage。")]),e._v(" "),n("li",[e._v("b：32bit，表示subPage的bitmapIdx。如果不是subPage就是0.")])]),e._v(" "),n("p",[e._v("runsAvailMap：")]),e._v(" "),n("ul",[n("li",[e._v("key: runOffset")]),e._v(" "),n("li",[e._v("value: handle")])]),e._v(" "),n("p",[e._v("runsAvail:")]),e._v(" "),n("p",[e._v("优先队列的列表。每个优先队列管理相同大小的run。run通过offset设置优先级，所以每次都可以分配最小offset的run。")]),e._v(" "),n("h4",{attrs:{id:"算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[e._v("#")]),e._v(" 算法")]),e._v(" "),n("p",[e._v("allocateRun(size):")]),e._v(" "),n("ol",[n("li",[e._v("找到第一个满足要求的run")]),e._v(" "),n("li",[e._v("如果run的page比需要的多，run分裂，分裂后面的留给后续使用。")])]),e._v(" "),n("p",[e._v("allocateSubpage(size):")]),e._v(" "),n("ol",[n("li",[e._v("找到第一个满足size没满的subpage。如果找到了直接返回，否则分配一个新的PoolSubpage。")]),e._v(" "),n("li",[e._v("执行SubPage的分配（allocate）。")])]),e._v(" "),n("p",[e._v("free(handle, len, buffer)")]),e._v(" "),n("ol",[n("li",[e._v("如果释放的是subpage，那么释放当前标记。")]),e._v(" "),n("li",[e._v("如果subpage没被使用，或者是一个run，那么释放。")]),e._v(" "),n("li",[e._v("合并连续的可用run。")]),e._v(" "),n("li",[e._v("保存合并后的run。")])])])}),[],!1,null,null,null);n.default=o.exports}}]);