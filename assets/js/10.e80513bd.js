(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{289:function(s,a,t){s.exports=t.p+"assets/img/basic_structure.98aa11d4.png"},290:function(s,a,t){s.exports=t.p+"assets/img/2021-09-02T172225.c1a8ce39.png"},327:function(s,a,t){"use strict";t.r(a);var e=t(14),n=Object(e.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"初探jgroups"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初探jgroups"}},[s._v("#")]),s._v(" 初探JGroups")]),s._v(" "),a("blockquote",[a("p",[s._v("此处使用JGroup 4.x版本，基于JDK 8")])]),s._v(" "),a("h2",{attrs:{id:"基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[s._v("#")]),s._v(" 基本概念")]),s._v(" "),a("p",[s._v("JGroup是一个可靠的组播，或者叫组内通讯的工具。（Group Communication）其基本概念包括组（group）和组员（member）。组员可以具体为一个节点，而组可以具体为一个集群。")]),s._v(" "),a("p",[s._v("一个组内的节点可以是在同一个host下，也可以在同一个局域网下，也可以是在WAN中的。一个组员可以是多个组的成员。")]),s._v(" "),a("p",[s._v("在日常使用中，我们会遇到例如集群中某个节点需要向整个集群节点发送信息的场景（比如广播），这个时候JGroup就派上用场了。")]),s._v(" "),a("h2",{attrs:{id:"基本结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本结构"}},[s._v("#")]),s._v(" 基本结构")]),s._v(" "),a("p",[a("img",{attrs:{src:t(289),alt:""}})]),s._v(" "),a("p",[s._v("网络传输层之上，JGroup主要有三部分。分别是Building blocks、JChannel和protocol stack。")]),s._v(" "),a("h3",{attrs:{id:"building-blocks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#building-blocks"}},[s._v("#")]),s._v(" Building Blocks")]),s._v(" "),a("p",[s._v("Building Blocks是一个比较上层的概念，也是一个可选项。我们编程时可以绕过Building Blocks直接和JChannel进行交互，也是没有问题的。Building Blocks的设计初衷是将程序设计者从单调乏味的一些create、send、receive、disconnect等JChannel的代码中解放出来。简单的理解Building Blocks就是针对JChannel的一个封装，上层应用可以直接和Building Blocks进行交互。")]),s._v(" "),a("h3",{attrs:{id:"jchannel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jchannel"}},[s._v("#")]),s._v(" JChannel")]),s._v(" "),a("p",[s._v("对于JGroup中的一个组（group），都有一个唯一标识group name（组名）进行识别。映射为JChannel可以理解为，JChannel中名字相同的JChannel集合，抽象为一个组（group）。")]),s._v(" "),a("p",[s._v("应用程序想成为某个组的组员，就需要在程序中创建一个JChannel，并通过组名将JChannel连接到组中。一旦连接成功，组员就可以向组内其他成员发送信息，并接收组内其他成员的信息了。需要注意的是，一个JChannel同一时间内只能连接一个组（也就是说connect到一个name）。如果一个进程想连接到多个组，就必须创建多个JChannel，依次连接。")]),s._v(" "),a("p",[s._v("JChannel在被关闭（close）前，是可以被重用的。也就是说，一个组员可以在JChannel断开（disconnected）后，再次使用JChannel连接到当前组中。")]),s._v(" "),a("p",[s._v("每个JChannel对应一个地址（Address），JChannel中维护了一个所有组员列表的视图（view），因此组员也可以通过指定某个地址的方式，来给指定的组员发送消息。默认情况下组员通过JChannel发送消息会给所有的组内成员，包括自己发送。当组内成员发生改变时，新生成的视图会发送给所有当前组内的所有成员。")]),s._v(" "),a("h3",{attrs:{id:"协议栈-protocol-stack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协议栈-protocol-stack"}},[s._v("#")]),s._v(" 协议栈（Protocol Stack）")]),s._v(" "),a("p",[s._v("协议栈在一个双向列表中保存了一系列协议（注意不是网络协议）。所有的发送和接收的信息，都需要经过协议栈中的所有层（layer）。这就意味着，每一个协议栈中的layer都有可能针对这个信息进行修改、记录、pass或者drop，或添加一个头元素。")]),s._v(" "),a("p",[s._v("其实这个有点像Netty中的handler，也有点像传统的网络模型。也就是说一个信息在发送前需要经过一系列的处理，例如拆分信息、添加信息头、聚合信息等。")]),s._v(" "),a("h2",{attrs:{id:"基本接口概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本接口概念"}},[s._v("#")]),s._v(" 基本接口概念")]),s._v(" "),a("h3",{attrs:{id:"地址address"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#地址address"}},[s._v("#")]),s._v(" 地址Address")]),s._v(" "),a("p",[s._v("每个组的成员通过地址来作为组员的唯一标识符。默认的地址实现是org.jgroups.util.UUID，显然是基于当前节点的IP address和port生成了uuid。")]),s._v(" "),a("p",[s._v("需要注意的是，一般uuid的Address不会被显示地使用，通常是在发送信息的时候被作为发送标识，比如发给指定的组员。")]),s._v(" "),a("p",[s._v("通常显示使用的是逻辑名（logical name），也就是程序中可以指定给节点的名字。这样更可读一点。")]),s._v(" "),a("p",[s._v("也可以通过开启TP.use_ip_addrs来使用IpAddressUUIDs，这个操作在原始uuid上加入了随机因子，来避免重启一个组员的时候，由于在同一个address和port而导致使用了相同的标识符。另一个好处是IpAddressUUIDs保存了物理地址，避免了每次信息交换的时候uuid和ipaddress之间的转换。")]),s._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("interface")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Address")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("extends")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Streamable")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Comparable")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Address")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("size")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),a("p",[s._v("Address中的size主要是为了在实际发送数据时可以计算出序列化的长度。而Comparable接口保证了当组发生分裂或合并时（一个组变成两个组、两个组合并），可以保证生成的view按照需要的顺序进行排列。")]),s._v(" "),a("h3",{attrs:{id:"消息message"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息message"}},[s._v("#")]),s._v(" 消息Message")]),s._v(" "),a("p",[s._v("org.jgroups.Message封装了组员之间需要传输的数据。数据通常逻辑上包括以下四个部分：目的地址（dest）、源地址（src）、头（headers）和实际装入的数据（payload）。")]),s._v(" "),a("p",[a("img",{attrs:{src:t(290),alt:"2021-09-02T172225"}})]),s._v(" "),a("p",[s._v("其中源地址和目的地址可以是null。这里需要解释的是，null并不代表实际发送的时候为null。消息最终会经过协议栈Protocol Stack中的每一层（layer）来进行进一步加工。因此在某一步中的null，实际是具有含义的。源地址null需要发送的layer来实际指定当前地址。而目的地址null表示当前信息是发送给所有组员的。")]),s._v(" "),a("p",[s._v("头信息其实是指所有不放在payload的部分。其中包括了很多其他信息，比如Flags。")]),s._v(" "),a("p",[s._v("消息也有MessageBatch功能，意思是批量发送，来避免频繁的同步过程，减少潜在的加锁次数。")]),s._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// get dest")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Message")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("getDest")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// get src")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Message")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("getSrc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])])]),a("h3",{attrs:{id:"view"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#view"}},[s._v("#")]),s._v(" View")]),s._v(" "),a("p",[s._v("org.jgroups.View是视图的抽象。View包含一个当前组的组员列表和ViewId。")]),s._v(" "),a("p",[s._v("每个组在创建的时候，组员列表中的第一个组员（或者说第一个创建组的成员，当然两者不一定是相同的，不相同以view中列表第一个为准）被称为coordinator协调人。coordinator负责view的创建。")]),s._v(" "),a("p",[s._v("也就是说，当组中组员发生变化时，每一个组员可以方便地获取coordinator并且从其获取最新的view，而不需要与其他组员交互。")]),s._v(" "),a("p",[s._v("因此，ViewId中含有两部分信息，一个是创建当前view的节点地址，一个是序列号sequence number。二者可以用来标识出一个唯一的ViewId。")]),s._v(" "),a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[s._v("#")]),s._v(" 参考")]),s._v(" "),a("ul",[a("li",[s._v("http://www.jgroups.org/manual5/index.html")])])])}),[],!1,null,null,null);a.default=n.exports}}]);