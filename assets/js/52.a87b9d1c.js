(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{343:function(e,t,n){"use strict";n.r(t);var s=n(14),a=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("blockquote",[t("p",[e._v("基于Redis 6.0")])]),e._v(" "),t("p",[e._v("压缩列表中单个元素结构ziplistEntry")]),e._v(" "),t("div",{staticClass:"language-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// src/ziplist.h")]),e._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* Each entry in the ziplist is either a string or an integer. */")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("typedef")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("struct")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* When string is used, it is provided with the length (slen). */")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("char")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v("sval"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" slen"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* When integer is used, 'sval' is NULL, and lval holds the value. */")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("long")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("long")]),e._v(" lval"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" ziplistEntry"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),t("p",[e._v("整个压缩列表结构为：")]),e._v(" "),t("ol",[t("li",[e._v("列表头zlbytes，4字节表示压缩列表字节长度，包括自己。")]),e._v(" "),t("li",[e._v("列表头zltail，4字节标识最后一个entry的偏移量。")]),e._v(" "),t("li",[e._v("列表头zllen，2字节标识entry数量。超过2^16-2的情况下会记为2^16-1并且失效，进而获取数量需要通过遍历获取。")]),e._v(" "),t("li",[e._v("entry，实际元素。")]),e._v(" "),t("li",[e._v("列表尾zlend，1字节=255，标识列表结束。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<zlbytes> <zltail> <zllen> <entry> <entry> ... <entry> <zlend>\n")])])]),t("p",[e._v("单个entry的结构为：")]),e._v(" "),t("ol",[t("li",[e._v("prevlen。上一个entry的长度。如果上一个entry长度小于254bytes，则用一个字节表示。如果大于等于254bytes，则用5个字节，第一个字节设置254作为标识位，下4个字节表示长度。")]),e._v(" "),t("li",[e._v("encoding，表示当前entry的编码。encoding逻辑比较复杂见下文。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<prevlen> <encoding> <entry-data>\n\nOr alternatively if the previous entry length is greater than 253 bytes the following encoding is used:\n\n0xFE <4 bytes unsigned little endian prevlen> <encoding> <entry>\n")])])]),t("p",[e._v("特殊情况下，如int类型比较小，encoding直接表示为data本身，则entry-data为null。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<prevlen> <encoding>\n")])])]),t("p",[e._v("encoding编码逻辑：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' * |00pppppp| - 1 byte\n *      String value with length less than or equal to 63 bytes (6 bits).\n *      "pppppp" represents the unsigned 6 bit length.\n * |01pppppp|qqqqqqqq| - 2 bytes\n *      String value with length less than or equal to 16383 bytes (14 bits).\n *      IMPORTANT: The 14 bit number is stored in big endian.\n * |10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes\n *      String value with length greater than or equal to 16384 bytes.\n *      Only the 4 bytes following the first byte represents the length\n *      up to 2^32-1. The 6 lower bits of the first byte are not used and\n *      are set to zero.\n *      IMPORTANT: The 32 bit number is stored in big endian.\n * |11000000| - 3 bytes\n *      Integer encoded as int16_t (2 bytes).\n * |11010000| - 5 bytes\n *      Integer encoded as int32_t (4 bytes).\n * |11100000| - 9 bytes\n *      Integer encoded as int64_t (8 bytes).\n * |11110000| - 4 bytes\n *      Integer encoded as 24 bit signed (3 bytes).\n * |11111110| - 2 bytes\n *      Integer encoded as 8 bit signed (1 byte).\n * |1111xxxx| - (with xxxx between 0001 and 1101) immediate 4 bit integer.\n *      Unsigned integer from 0 to 12. The encoded value is actually from\n *      1 to 13 because 0000 and 1111 can not be used, so 1 should be\n *      subtracted from the encoded 4 bit value to obtain the right value.\n * |11111111| - End of ziplist special entry.\n')])])])])}),[],!1,null,null,null);t.default=a.exports}}]);